#!/bin/bash

# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║  CloudSync Ultra - Pre-commit Hook                                         ║
# ║  Catches errors BEFORE they reach the repo                                 ║
# ╚═══════════════════════════════════════════════════════════════════════════╝
#
# This hook runs automatically before each commit.
# If any check fails, the commit is rejected.
#
# Install: ./scripts/install-hooks.sh
# Bypass (emergency only): git commit --no-verify

set -e

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color
BOLD='\033[1m'

# Get project root
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
if [[ "$SCRIPT_DIR" == *".git/hooks"* ]]; then
    PROJECT_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"
else
    PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
fi

cd "$PROJECT_ROOT"

echo ""
echo -e "${BLUE}${BOLD}┌─────────────────────────────────────────┐${NC}"
echo -e "${BLUE}${BOLD}│     Pre-commit Quality Gate             │${NC}"
echo -e "${BLUE}${BOLD}└─────────────────────────────────────────┘${NC}"
echo ""

ERRORS=0
WARNINGS=0

# ─────────────────────────────────────────────────────────────────────────────
# Check 1: Swift files syntax check (fast)
# ─────────────────────────────────────────────────────────────────────────────
echo -e "${BLUE}[1/9]${NC} Checking Swift syntax..."

# Get staged Swift files
STAGED_SWIFT=$(git diff --cached --name-only --diff-filter=ACM | grep "\.swift$" || true)

if [[ -n "$STAGED_SWIFT" ]]; then
    SYNTAX_ERRORS=0
    while IFS= read -r file; do
        if [[ -f "$file" ]]; then
            # Quick syntax check using swiftc -parse
            if ! swiftc -parse "$file" 2>/dev/null; then
                echo -e "  ${RED}✗${NC} Syntax error: $file"
                SYNTAX_ERRORS=$((SYNTAX_ERRORS + 1))
            fi
        fi
    done <<< "$STAGED_SWIFT"
    
    if [[ $SYNTAX_ERRORS -eq 0 ]]; then
        echo -e "  ${GREEN}✓${NC} Swift syntax OK ($(echo "$STAGED_SWIFT" | wc -l | tr -d ' ') files)"
    else
        echo -e "  ${RED}✗${NC} $SYNTAX_ERRORS syntax errors found"
        ERRORS=$((ERRORS + SYNTAX_ERRORS))
    fi
else
    echo -e "  ${GREEN}✓${NC} No Swift files staged"
fi

# ─────────────────────────────────────────────────────────────────────────────
# Check 2: SwiftFormat (auto-fix formatting)
# ─────────────────────────────────────────────────────────────────────────────
echo -e "${BLUE}[2/9]${NC} Running SwiftFormat..."

if command -v swiftformat &> /dev/null; then
    if [[ -n "$STAGED_SWIFT" ]]; then
        # Auto-format staged files
        FORMAT_COUNT=0
        while IFS= read -r file; do
            if [[ -f "$file" ]]; then
                # Run swiftformat on the file
                swiftformat "$file" --quiet 2>/dev/null

                # Check if file was modified
                if ! git diff --quiet "$file" 2>/dev/null; then
                    FORMAT_COUNT=$((FORMAT_COUNT + 1))
                    # Re-stage the formatted file
                    git add "$file"
                fi
            fi
        done <<< "$STAGED_SWIFT"

        if [[ $FORMAT_COUNT -gt 0 ]]; then
            echo -e "  ${GREEN}✓${NC} SwiftFormat: auto-fixed $FORMAT_COUNT file(s)"
        else
            echo -e "  ${GREEN}✓${NC} SwiftFormat: all files formatted"
        fi
    else
        echo -e "  ${GREEN}✓${NC} No Swift files to format"
    fi
else
    echo -e "  ${YELLOW}⚠${NC} SwiftFormat not installed (brew install swiftformat)"
    WARNINGS=$((WARNINGS + 1))
fi

# ─────────────────────────────────────────────────────────────────────────────
# Check 3: SwiftLint (code style)
# ─────────────────────────────────────────────────────────────────────────────
echo -e "${BLUE}[3/9]${NC} Running SwiftLint..."

if command -v swiftlint &> /dev/null; then
    if [[ -n "$STAGED_SWIFT" ]]; then
        # Run SwiftLint only on staged files for speed
        LINT_OUTPUT=$(echo "$STAGED_SWIFT" | xargs swiftlint lint --quiet 2>&1 || true)
        LINT_ERRORS=$(echo "$LINT_OUTPUT" | grep -c "error:" || true)
        LINT_WARNINGS=$(echo "$LINT_OUTPUT" | grep -c "warning:" || true)

        if [[ $LINT_ERRORS -gt 0 ]]; then
            echo -e "  ${RED}✗${NC} SwiftLint: $LINT_ERRORS error(s), $LINT_WARNINGS warning(s)"
            echo "$LINT_OUTPUT" | grep "error:" | head -5
            ERRORS=$((ERRORS + 1))
        elif [[ $LINT_WARNINGS -gt 0 ]]; then
            echo -e "  ${YELLOW}⚠${NC} SwiftLint: $LINT_WARNINGS warning(s)"
            WARNINGS=$((WARNINGS + 1))
        else
            echo -e "  ${GREEN}✓${NC} SwiftLint passed"
        fi
    else
        echo -e "  ${GREEN}✓${NC} No Swift files to lint"
    fi
else
    echo -e "  ${YELLOW}⚠${NC} SwiftLint not installed (brew install swiftlint)"
    WARNINGS=$((WARNINGS + 1))
fi

# ─────────────────────────────────────────────────────────────────────────────
# Check 4: Build check (critical)
# ─────────────────────────────────────────────────────────────────────────────
echo -e "${BLUE}[4/9]${NC} Building project..."

# Only do full build if Swift files changed
if [[ -n "$STAGED_SWIFT" ]]; then
    BUILD_OUTPUT=$(xcodebuild build \
        -project CloudSyncApp.xcodeproj \
        -scheme CloudSyncApp \
        -destination 'platform=macOS' \
        -quiet \
        2>&1) || BUILD_FAILED=1
    
    if [[ -n "$BUILD_FAILED" ]]; then
        echo -e "  ${RED}✗${NC} Build FAILED"
        echo ""
        echo -e "${RED}Build errors:${NC}"
        echo "$BUILD_OUTPUT" | grep -E "error:" | head -10
        echo ""
        ERRORS=$((ERRORS + 1))
    else
        echo -e "  ${GREEN}✓${NC} Build succeeded"
    fi
else
    echo -e "  ${GREEN}✓${NC} Skipped (no Swift changes)"
fi

# ─────────────────────────────────────────────────────────────────────────────
# Check 5: Version consistency (strict when committing version-related files)
# ─────────────────────────────────────────────────────────────────────────────
echo -e "${BLUE}[5/9]${NC} Checking version consistency..."

# Check if version-related files are being committed
VERSION_FILES_STAGED=$(git diff --cached --name-only | grep -E "(VERSION\.txt|CHANGELOG|README\.md|STATUS\.md|RECOVERY\.md|PROJECT_CONTEXT\.md|CLAUDE_PROJECT_KNOWLEDGE\.md|project\.json|project\.pbxproj)" || true)

if [[ -x "./scripts/version-check.sh" ]]; then
    if ./scripts/version-check.sh > /dev/null 2>&1; then
        echo -e "  ${GREEN}✓${NC} Versions aligned"
    else
        if [[ -n "$VERSION_FILES_STAGED" ]]; then
            # BLOCK if committing version-related files with mismatch
            echo -e "  ${RED}✗${NC} Version mismatch - run ./scripts/update-version.sh"
            echo -e "      Staged version files: $(echo "$VERSION_FILES_STAGED" | wc -l | tr -d ' ')"
            ERRORS=$((ERRORS + 1))
        else
            # Warning only for unrelated commits
            echo -e "  ${YELLOW}⚠${NC} Version mismatch (run ./scripts/update-version.sh)"
            WARNINGS=$((WARNINGS + 1))
        fi
    fi
else
    echo -e "  ${YELLOW}⚠${NC} version-check.sh not found"
fi

# ─────────────────────────────────────────────────────────────────────────────
# Check 6: No debug code left behind
# ─────────────────────────────────────────────────────────────────────────────
echo -e "${BLUE}[6/9]${NC} Checking for debug artifacts..."

DEBUG_PATTERNS=(
    "print(\"DEBUG"
    "// TODO: REMOVE"
    "// FIXME: BEFORE COMMIT"
    "fatalError(\"DEBUG"
    "\.debug\s*=\s*true"
)

DEBUG_FOUND=0
for pattern in "${DEBUG_PATTERNS[@]}"; do
    if [[ -n "$STAGED_SWIFT" ]]; then
        MATCHES=$(echo "$STAGED_SWIFT" | xargs grep -l "$pattern" 2>/dev/null || true)
        if [[ -n "$MATCHES" ]]; then
            echo -e "  ${YELLOW}⚠${NC} Found '$pattern' in:"
            echo "$MATCHES" | sed 's/^/      /'
            DEBUG_FOUND=$((DEBUG_FOUND + 1))
        fi
    fi
done

if [[ $DEBUG_FOUND -eq 0 ]]; then
    echo -e "  ${GREEN}✓${NC} No debug artifacts"
else
    WARNINGS=$((WARNINGS + DEBUG_FOUND))
fi

# ─────────────────────────────────────────────────────────────────────────────
# Check 7: Large files check
# ─────────────────────────────────────────────────────────────────────────────
echo -e "${BLUE}[7/9]${NC} Checking for large files..."

LARGE_FILES=$(git diff --cached --name-only | while read file; do
    if [[ -f "$file" ]]; then
        SIZE=$(wc -c < "$file" | tr -d ' ')
        if [[ $SIZE -gt 1048576 ]]; then  # 1MB
            echo "$file ($((SIZE / 1024))KB)"
        fi
    fi
done)

if [[ -n "$LARGE_FILES" ]]; then
    echo -e "  ${YELLOW}⚠${NC} Large files (>1MB):"
    echo "$LARGE_FILES" | sed 's/^/      /'
    WARNINGS=$((WARNINGS + 1))
else
    echo -e "  ${GREEN}✓${NC} No large files"
fi

# ─────────────────────────────────────────────────────────────────────────────
# Check 8: Duplicate filename detection
# ─────────────────────────────────────────────────────────────────────────────
echo -e "${BLUE}[8/9]${NC} Checking for duplicate filenames..."

# Get newly added Swift files
ADDED_FILES=$(git diff --cached --name-only --diff-filter=A | grep "\.swift$" || true)

if [[ -n "$ADDED_FILES" ]]; then
    DUPE_FOUND=0
    while IFS= read -r file; do
        if [[ -n "$file" ]]; then
            basename=$(basename "$file")
            # Search in source directories only (exclude archive, build, DerivedData)
            count=$(find CloudSyncApp CloudSyncAppTests CloudSyncAppUITests \
                -name "$basename" -type f 2>/dev/null | wc -l | tr -d ' ')
            if [[ $count -gt 1 ]]; then
                echo -e "  ${YELLOW}⚠${NC} Duplicate: $basename exists in multiple locations:"
                find CloudSyncApp CloudSyncAppTests CloudSyncAppUITests \
                    -name "$basename" -type f 2>/dev/null | sed 's/^/      /'
                DUPE_FOUND=$((DUPE_FOUND + 1))
            fi
        fi
    done <<< "$ADDED_FILES"

    if [[ $DUPE_FOUND -eq 0 ]]; then
        echo -e "  ${GREEN}✓${NC} No duplicate filenames"
    else
        WARNINGS=$((WARNINGS + DUPE_FOUND))
    fi
else
    echo -e "  ${GREEN}✓${NC} No new Swift files added"
fi

# ─────────────────────────────────────────────────────────────────────────────
# Check 9: Test coverage check (80% minimum)
# ─────────────────────────────────────────────────────────────────────────────
echo -e "${BLUE}[9/9]${NC} Checking test coverage..."

# Only run coverage check when Swift source files are staged
STAGED_SOURCE=$(git diff --cached --name-only --diff-filter=ACM | grep "^CloudSyncApp/.*\.swift$" || true)

if [[ -n "$STAGED_SOURCE" ]]; then
    # Use temp result bundle for reliable coverage extraction
    RESULT_BUNDLE="/tmp/PreCommitTestResults.xcresult"
    rm -rf "$RESULT_BUNDLE" 2>/dev/null || true

    # Run unit tests with coverage enabled (skip UI tests for speed)
    TEST_OUTPUT=$(xcodebuild test \
        -project CloudSyncApp.xcodeproj \
        -scheme CloudSyncApp \
        -destination 'platform=macOS' \
        -skip-testing:CloudSyncAppUITests \
        -enableCodeCoverage YES \
        -resultBundlePath "$RESULT_BUNDLE" \
        -quiet \
        2>&1) || TEST_FAILED=1

    # Check for result bundle (created even with expected failures)
    if [[ -d "$RESULT_BUNDLE" ]]; then
        # Get coverage report (line 3 has overall coverage after header/dashes)
        COVERAGE_LINE=$(xcrun xccov view --report "$RESULT_BUNDLE" 2>/dev/null | head -3 | tail -1)

        if [[ -n "$COVERAGE_LINE" ]]; then
            # Extract percentage (format: "Name  XX.XX% (n/m)")
            COVERAGE_PCT=$(echo "$COVERAGE_LINE" | grep -oE "[0-9]+\.[0-9]+%" | head -1 | tr -d '%')

            if [[ -n "$COVERAGE_PCT" ]]; then
                COVERAGE_INT=$(echo "$COVERAGE_PCT" | cut -d'.' -f1)

                if [[ $COVERAGE_INT -ge 80 ]]; then
                    echo -e "  ${GREEN}✓${NC} Coverage: ${COVERAGE_INT}% (minimum: 80%)"
                else
                    echo -e "  ${YELLOW}⚠${NC} Coverage: ${COVERAGE_INT}% (below 80% minimum)"
                    echo -e "      Consider adding tests to improve coverage"
                    WARNINGS=$((WARNINGS + 1))
                fi
            else
                echo -e "  ${YELLOW}⚠${NC} Could not parse coverage data"
            fi
        else
            echo -e "  ${YELLOW}⚠${NC} Coverage report not available"
        fi

        # Cleanup
        rm -rf "$RESULT_BUNDLE" 2>/dev/null || true
    elif [[ -n "$TEST_FAILED" ]]; then
        echo -e "  ${RED}✗${NC} Tests failed - cannot check coverage"
        ERRORS=$((ERRORS + 1))
    else
        echo -e "  ${YELLOW}⚠${NC} No test results generated"
    fi
else
    echo -e "  ${GREEN}✓${NC} Skipped (no source changes)"
fi

# ─────────────────────────────────────────────────────────────────────────────
# Summary
# ─────────────────────────────────────────────────────────────────────────────
echo ""
echo -e "${BLUE}${BOLD}─────────────────────────────────────────${NC}"

if [[ $ERRORS -gt 0 ]]; then
    echo -e "${RED}${BOLD}✗ COMMIT BLOCKED${NC}"
    echo -e "  ${RED}$ERRORS error(s) must be fixed${NC}"
    if [[ $WARNINGS -gt 0 ]]; then
        echo -e "  ${YELLOW}$WARNINGS warning(s)${NC}"
    fi
    echo ""
    echo -e "${YELLOW}Fix errors and try again.${NC}"
    echo -e "${YELLOW}Emergency bypass: git commit --no-verify${NC}"
    echo ""
    exit 1
elif [[ $WARNINGS -gt 0 ]]; then
    echo -e "${YELLOW}${BOLD}⚠ COMMIT ALLOWED (with warnings)${NC}"
    echo -e "  ${YELLOW}$WARNINGS warning(s) - consider fixing${NC}"
    echo ""
else
    echo -e "${GREEN}${BOLD}✓ ALL CHECKS PASSED${NC}"
    echo ""
fi

exit 0
